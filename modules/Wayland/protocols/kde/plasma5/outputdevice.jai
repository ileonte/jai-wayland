/*
 * Auto-generated by `wayland-scanner` version 1.0.1
 * Protocol: org_kde_kwin_outputdevice
 */

org_kde_kwin_outputdevice_interface: wl_interface;
org_kde_kwin_outputdevice :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *org_kde_kwin_outputdevice_interface;

    /* ENUM: org_kde_kwin_outputdevice::subpixel */
    subpixel_unknown        : u32 : 0;
    subpixel_none           : u32 : 1;
    subpixel_horizontal_rgb : u32 : 2;
    subpixel_horizontal_bgr : u32 : 3;
    subpixel_vertical_rgb   : u32 : 4;
    subpixel_vertical_bgr   : u32 : 5;

    /* ENUM: org_kde_kwin_outputdevice::transform */
    transform_normal      : u32 : 0;
    transform_90          : u32 : 1;
    transform_180         : u32 : 2;
    transform_270         : u32 : 3;
    transform_flipped     : u32 : 4;
    transform_flipped_90  : u32 : 5;
    transform_flipped_180 : u32 : 6;
    transform_flipped_270 : u32 : 7;

    /* ENUM: org_kde_kwin_outputdevice::mode */
    mode_current   : u32 : 0x1;
    mode_preferred : u32 : 0x2;

    /* ENUM: org_kde_kwin_outputdevice::enablement */
    enablement_disabled : u32 : 0;
    enablement_enabled  : u32 : 1;

    /* ENUM: org_kde_kwin_outputdevice::capability */
    capability_overscan : u32 : 1;
    capability_vrr      : u32 : 2;

    /* ENUM: org_kde_kwin_outputdevice::vrr_policy */
    vrr_policy_never     : u32 : 0;
    vrr_policy_always    : u32 : 1;
    vrr_policy_automatic : u32 : 2;

    set_user_data :: inline (self: *org_kde_kwin_outputdevice, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *org_kde_kwin_outputdevice) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *org_kde_kwin_outputdevice) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *org_kde_kwin_outputdevice) #c_call {
        wl_proxy.destroy(self);
    }

    add_listener :: inline (self: *org_kde_kwin_outputdevice, listener: *org_kde_kwin_outputdevice_listener, data: *void) -> s32 #c_call {
        return wl_proxy.add_listener(self, cast(*generic_c_call) listener, data);
    }
}
ORG_KDE_KWIN_OUTPUTDEVICE_GEOMETRY_SINCE      : u32 : 1;
ORG_KDE_KWIN_OUTPUTDEVICE_MODE_SINCE          : u32 : 1;
ORG_KDE_KWIN_OUTPUTDEVICE_DONE_SINCE          : u32 : 1;
ORG_KDE_KWIN_OUTPUTDEVICE_SCALE_SINCE         : u32 : 1;
ORG_KDE_KWIN_OUTPUTDEVICE_EDID_SINCE          : u32 : 1;
ORG_KDE_KWIN_OUTPUTDEVICE_ENABLED_SINCE       : u32 : 1;
ORG_KDE_KWIN_OUTPUTDEVICE_UUID_SINCE          : u32 : 1;
ORG_KDE_KWIN_OUTPUTDEVICE_SCALEF_SINCE        : u32 : 2;
ORG_KDE_KWIN_OUTPUTDEVICE_COLORCURVES_SINCE   : u32 : 2;
ORG_KDE_KWIN_OUTPUTDEVICE_SERIAL_NUMBER_SINCE : u32 : 2;
ORG_KDE_KWIN_OUTPUTDEVICE_EISA_ID_SINCE       : u32 : 2;
ORG_KDE_KWIN_OUTPUTDEVICE_CAPABILITIES_SINCE  : u32 : 3;
ORG_KDE_KWIN_OUTPUTDEVICE_OVERSCAN_SINCE      : u32 : 3;
ORG_KDE_KWIN_OUTPUTDEVICE_VRR_POLICY_SINCE    : u32 : 4;

org_kde_kwin_outputdevice_listener :: struct {
    geometry      := _stubs_.geometry;
    mode          := _stubs_.mode;
    done          := _stubs_.done;
    scale         := _stubs_.scale;
    edid          := _stubs_.edid;
    enabled       := _stubs_.enabled;
    uuid          := _stubs_.uuid;
    scalef        := _stubs_.scalef;
    colorcurves   := _stubs_.colorcurves;
    serial_number := _stubs_.serial_number;
    eisa_id       := _stubs_.eisa_id;
    capabilities  := _stubs_.capabilities;
    overscan      := _stubs_.overscan;
    vrr_policy    := _stubs_.vrr_policy;

    _stubs_ :: struct {
        geometry :: (data: *void,
            self: *org_kde_kwin_outputdevice,
            x: s32,
            y: s32,
            physical_width: s32,
            physical_height: s32,
            subpixel: s32,
            make: *u8,
            model: *u8,
            transform: s32) -> void #c_call {}
        mode :: (data: *void,
            self: *org_kde_kwin_outputdevice,
            flags: u32,
            width: s32,
            height: s32,
            refresh: s32,
            mode_id: s32) -> void #c_call {}
        done :: (data: *void,
            self: *org_kde_kwin_outputdevice) -> void #c_call {}
        scale :: (data: *void,
            self: *org_kde_kwin_outputdevice,
            factor: s32) -> void #c_call {}
        edid :: (data: *void,
            self: *org_kde_kwin_outputdevice,
            raw: *u8) -> void #c_call {}
        enabled :: (data: *void,
            self: *org_kde_kwin_outputdevice,
            enabled: s32) -> void #c_call {}
        uuid :: (data: *void,
            self: *org_kde_kwin_outputdevice,
            uuid: *u8) -> void #c_call {}
        scalef :: (data: *void,
            self: *org_kde_kwin_outputdevice,
            factor: wl_fixed_t) -> void #c_call {}
        colorcurves :: (data: *void,
            self: *org_kde_kwin_outputdevice,
            red: *wl_array,
            green: *wl_array,
            blue: *wl_array) -> void #c_call {}
        serial_number :: (data: *void,
            self: *org_kde_kwin_outputdevice,
            serialNumber: *u8) -> void #c_call {}
        eisa_id :: (data: *void,
            self: *org_kde_kwin_outputdevice,
            eisaId: *u8) -> void #c_call {}
        capabilities :: (data: *void,
            self: *org_kde_kwin_outputdevice,
            flags: u32) -> void #c_call {}
        overscan :: (data: *void,
            self: *org_kde_kwin_outputdevice,
            overscan: u32) -> void #c_call {}
        vrr_policy :: (data: *void,
            self: *org_kde_kwin_outputdevice,
            vrr_policy: u32) -> void #c_call {}
    }
}


#scope_module
org_kde_kwin_outputdevice_protocol_init :: () {
    org_kde_kwin_outputdevice_types_storage = .[
        /* __DUMMY__ */
        null,  // 0
        /* EVENT: org_kde_kwin_outputdevice::geometry */
        null,  // 1
        null,  // 2
        null,  // 3
        null,  // 4
        null,  // 5
        null,  // 6
        null,  // 7
        null,  // 8
        /* EVENT: org_kde_kwin_outputdevice::mode */
        null,  // 9
        null,  // 10
        null,  // 11
        null,  // 12
        null,  // 13
        /* EVENT: org_kde_kwin_outputdevice::scale */
        null,  // 14
        /* EVENT: org_kde_kwin_outputdevice::edid */
        null,  // 15
        /* EVENT: org_kde_kwin_outputdevice::enabled */
        null,  // 16
        /* EVENT: org_kde_kwin_outputdevice::uuid */
        null,  // 17
        /* EVENT: org_kde_kwin_outputdevice::scalef */
        null,  // 18
        /* EVENT: org_kde_kwin_outputdevice::colorcurves */
        null,  // 19
        null,  // 20
        null,  // 21
        /* EVENT: org_kde_kwin_outputdevice::serial_number */
        null,  // 22
        /* EVENT: org_kde_kwin_outputdevice::eisa_id */
        null,  // 23
        /* EVENT: org_kde_kwin_outputdevice::capabilities */
        null,  // 24
        /* EVENT: org_kde_kwin_outputdevice::overscan */
        null,  // 25
        /* EVENT: org_kde_kwin_outputdevice::vrr_policy */
        null,  // 26
    ];

    org_kde_kwin_outputdevice_events[0] = .{"geometry", "iiiiissi", org_kde_kwin_outputdevice_types_storage.data + 0};
    org_kde_kwin_outputdevice_events[1] = .{"mode", "uiiii", org_kde_kwin_outputdevice_types_storage.data + 1};
    org_kde_kwin_outputdevice_events[2] = .{"done", "", org_kde_kwin_outputdevice_types_storage.data + 0};
    org_kde_kwin_outputdevice_events[3] = .{"scale", "i", org_kde_kwin_outputdevice_types_storage.data + 9};
    org_kde_kwin_outputdevice_events[4] = .{"edid", "s", org_kde_kwin_outputdevice_types_storage.data + 14};
    org_kde_kwin_outputdevice_events[5] = .{"enabled", "i", org_kde_kwin_outputdevice_types_storage.data + 15};
    org_kde_kwin_outputdevice_events[6] = .{"uuid", "s", org_kde_kwin_outputdevice_types_storage.data + 16};
    org_kde_kwin_outputdevice_events[7] = .{"scalef", "f", org_kde_kwin_outputdevice_types_storage.data + 17};
    org_kde_kwin_outputdevice_events[8] = .{"colorcurves", "aaa", org_kde_kwin_outputdevice_types_storage.data + 18};
    org_kde_kwin_outputdevice_events[9] = .{"serial_number", "s", org_kde_kwin_outputdevice_types_storage.data + 19};
    org_kde_kwin_outputdevice_events[10] = .{"eisa_id", "s", org_kde_kwin_outputdevice_types_storage.data + 22};
    org_kde_kwin_outputdevice_events[11] = .{"capabilities", "u", org_kde_kwin_outputdevice_types_storage.data + 23};
    org_kde_kwin_outputdevice_events[12] = .{"overscan", "u", org_kde_kwin_outputdevice_types_storage.data + 24};
    org_kde_kwin_outputdevice_events[13] = .{"vrr_policy", "u", org_kde_kwin_outputdevice_types_storage.data + 25};
    org_kde_kwin_outputdevice_interface = .{
        "org_kde_kwin_outputdevice", 4,
        0, null,
        org_kde_kwin_outputdevice_events.count, org_kde_kwin_outputdevice_events.data,
    };
}


#scope_file
org_kde_kwin_outputdevice_types_storage: []*wl_interface;

org_kde_kwin_outputdevice_events  : [14]wl_message;

#assert size_of(org_kde_kwin_outputdevice) == 0 "wayland-scanner bug: org_kde_kwin_outputdevice is non-empty";
