/*
 * Auto-generated by `wayland-scanner` version 1.0.1
 * Protocol: wl_eglstream_controller
 */

wl_eglstream_controller_interface: wl_interface;
wl_eglstream_controller :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_eglstream_controller_interface;

    /* ENUM: wl_eglstream_controller::present_mode */
    present_mode_dont_care : u32 : 0;
    present_mode_fifo      : u32 : 1;
    present_mode_mailbox   : u32 : 2;

    /* ENUM: wl_eglstream_controller::attrib */
    attrib_present_mode : u32 : 0;
    attrib_fifo_length  : u32 : 1;

    set_user_data :: inline (self: *wl_eglstream_controller, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_eglstream_controller) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_eglstream_controller) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_eglstream_controller) #c_call {
        wl_proxy.destroy(self);
    }

    attach_eglstream_consumer :: inline (self: *wl_eglstream_controller, wl_surface: *wl_surface, wl_resource: *wl_buffer) #c_call {
        wl_proxy.marshal_flags(
            self, WL_EGLSTREAM_CONTROLLER_ATTACH_EGLSTREAM_CONSUMER,
            null, wl_proxy.get_version(self), 0,
            wl_surface, wl_resource);
    }

    attach_eglstream_consumer_attribs :: inline (self: *wl_eglstream_controller, wl_surface: *wl_surface, wl_resource: *wl_buffer, attribs: *wl_array) #c_call {
        wl_proxy.marshal_flags(
            self, WL_EGLSTREAM_CONTROLLER_ATTACH_EGLSTREAM_CONSUMER_ATTRIBS,
            null, wl_proxy.get_version(self), 0,
            wl_surface, wl_resource, attribs);
    }
}

WL_EGLSTREAM_CONTROLLER_ATTACH_EGLSTREAM_CONSUMER               : u32 : 0;
WL_EGLSTREAM_CONTROLLER_ATTACH_EGLSTREAM_CONSUMER_ATTRIBS       : u32 : 1;
WL_EGLSTREAM_CONTROLLER_ATTACH_EGLSTREAM_CONSUMER_SINCE         : u32 : 1;
WL_EGLSTREAM_CONTROLLER_ATTACH_EGLSTREAM_CONSUMER_ATTRIBS_SINCE : u32 : 2;


#scope_module
wl_eglstream_controller_protocol_init :: () {
    wl_eglstream_controller_types_storage = .[
        /* __DUMMY__ */
        null,  // 0
        /* REQUEST: wl_eglstream_controller::attach_eglstream_consumer */
        *wl_surface_interface,   // 1
        *wl_buffer_interface,   // 2
        /* REQUEST: wl_eglstream_controller::attach_eglstream_consumer_attribs */
        *wl_surface_interface,   // 3
        *wl_buffer_interface,   // 4
        null,  // 5
    ];

    wl_eglstream_controller_requests[0] = .{"attach_eglstream_consumer", "oo", wl_eglstream_controller_types_storage.data + 0};
    wl_eglstream_controller_requests[1] = .{"attach_eglstream_consumer_attribs", "ooa", wl_eglstream_controller_types_storage.data + 1};
    wl_eglstream_controller_interface = .{
        "wl_eglstream_controller", 2,
        wl_eglstream_controller_requests.count, wl_eglstream_controller_requests.data,
        0, null,
    };
}


#scope_file
wl_eglstream_controller_types_storage: []*wl_interface;

wl_eglstream_controller_requests: [2]wl_message;

#assert size_of(wl_eglstream_controller) == 0 "wayland-scanner bug: wl_eglstream_controller is non-empty";
